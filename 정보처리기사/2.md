# 2과목 

## 1. 데이터 입출력 구현

### 1) 자료구조

선형구조 : 배열, 선형리스트(연속리스트, 연결리스트), 스택(후입선출∪, 꽉차면 overFlow, 없으면 underflow), 큐(선입선출⇔), 데크

비선형구조 : 트리, 그래프(무방향:n(n-1)/2 방향:n(n-1))

### 2) 트리

노드와 브랜치를 이용해서 사이클이 이루어지지 않게 구성한 그래프

운행법 : preorder, Inoder, postorder -> 양쪽을 각각 숫자로 묶어서 배열한 뒤 숫자를 하나씩 풀어나가는 방식으러 계산

수식 표기법 : prefix(+AB), infix(A+B), postfix(AB-) -> 계산식을 다양한 방식으로 바꿀줄 알아야함.

### 3) 정렬(Sort)
( https://liveyourit.tistory.com/220 참고) 
#### (1) 삽입정렬 - 회차마다 이미 순서화 된 파일 사이에 비교파일 넣음

두번째를 첫번째와 비교 후 첫번째로 삽입  -> 1회전

세번째를 앞에 두개와 비교 후 첫번째 삽입 -> 2회전

네번째를 앞에 세개와 비교 후 첫번째 삽입...

회차마다 비교한 값들을 통채로 이동시킨다.

#### (2) 쉘 정렬 - 매개변수(h) 값으로 쪼갠 뒤 삽입정렬 반복

#### (3) 선택정렬 - 회차마다 n 번째와 비교해서 최소값을 찾아서 맨 앞에 넣는다.

첫번째 두번째 비교, 첫번째 세번째 비교, 첫번째 네번째 비교... -> 이게 1회전

두번째 세번째 비교, 두번째 네번째 비교, ... -> 2회전

...

#### (4) 버블정렬 - 인접한 두개의 레코드 비교해서 둘이 순서 바꿈

첫번째 두번째 비교, 두번째 세번째 비교, 세번째 네번째 비교... -> 1회전

1회전 후 다시 똑같이 첫번째 두번째 비교, 두번째 세번째 비교... -> 2회전

... 

이렇게 다 정렬 될때까지 진행함

#### (5) 퀵정렬 - 하나의 파일을 부분적으로 나누어 왼오 정렬

#### (6) 힙정렬 - 전이진 트리로 변환한 뒤 높은거를 위로 올림

#### (7) 2-way 정렬 - 2개씩 묶어서 한개로 캡슐화 한 뒤 캡슐끼리 비교

#### (8) 기수정렬 - 큐를 이용해서 자릿수별로 정렬. "버킷"에 분배했다가 꺼냄


### 4) 데이터 베이스 (공동, 운영, 통합, 저장)

여러사람에 의해 공동으로 사용될 데이터를 중복을 배제하여 통합하고 쉽게 접근하여 처리할 수 있도록 저장장치에 저장한 운영데이터의 모임.

DBMS 는 데이터베이스 관리 소프트웨어.

기능) 정의 명시, 조작가능, 제어가능(권한, 무결성, 병행제어, 보안)   단,DBMS는 종속성은 없음. 데이터가 독립적임.

스키마 는 데이터베이스 구조와 제약조건을 기술한 메타데이터이다.

종류) 외부 스키마(사용자가 필요로하는 논리적 구조), 개념 스키마(DB 전체 논리적 구조, 제약조건), 내부스키마(저장장치 종류, 데이터 형식)


### 5) 데이터 입출력

#### (1) SQL 종류

DDL(Data Manipulation Language) 데이터 정의어 : 테이블 정의, 도메인, 스키마, 뷰, 변경, 삭제 (SELECT INSERT UPDATE DELETE)
DML(Data Definition Language) 데이터 조작어 : 질의어, 찾거나 조작 (CREATE ALTER DROP RENAME TRUNCATE)
DCL(Data Control Language) 데이터 제어어 : 데이터 보안, 무결성, 회복, 병행수행제어 (GRANT REVOKE)

#### (3) 트랜잭션 제어어

DB 상태를 변환시키는 하나의 작업단위 또는 연산

TCL(Transaction Control Language) 트랜잭션 제어어 : 작업단위(트랜젝션)마다 제어함. (COMMIT ROLLBACK SAVEPOINT)

#### (4) 절차형 SQL

DB 전용 간단한 프로그래밍인데 연속적이고 반복적인 시행을 모듈화해서 시행한다.

종류) 

프로시저(미리 특정 기능을 저장해놓은 트랜젝션 언어들)

트리거(데이터 입력, 삭제, 갱신 등이 일어나면 시행되는 SQL들)

사용자정의함수(사용자가 미리 만들어 저장한 SQL 실행 후 처리 결과를 성공/실패 등 단일값으로 반환하게끔 해주는 함수)


<hr>

## 2. 통합구현

단위 모듈과 테스트 방법

IPC : 프로세스간 통신 방법인데, 방법이 여러가지이다.

PIPE를 통해서 데이터가 흘러가면서 처리되거나, Message Queue의 경우 PIPE 처럼 큐의 선입선출 구조를 따르지만 얘는 메모리 공간이다.

아예 공유 메모리(Shared Memory)에 데이터를 함께 사용하거나, 소캣(Socket)을 이용해서 네트워크 통신을 하기도 한다.

Semaphore의 경우 프로세스 간 데이터의 동기화를 보호한다.

<hr>



## 3. 소프트웨어 개발
### 1) 소프트웨어 패키징

소프트웨어 패키징 : 기능별(=모듈별)로 생성한 실행파일들을 묶어 배포용 설치 파일을 만드는 것.

실행파일은 소스 코드 향후 관리를 고려해서 모듈화한다.

이 패키징은 개발자가 아니라 사용자가 사용할 것으로 생각하고 진행하며, 다양한 환경에서도 손쉽게 사용 가능하도록 일반적인 배포 형태로 패키징한다.

#### (1) 패키징 고려사항

- 사용자의 시스템 환경을 고려한다.
- UI는 사용자가 눈으로 직접 확인할 수 있도록 시각적인 자료와 메뉴얼을 함께 패키징한다.
- Managed Service 형태로 제공해서 문제발생 시 즉각 점검 수행이 가능하도록 한다.
- 내부 콘텐츠 암호화 및 보안을 고려한다.
- 여러 콘텐츠 간 DRM(디지털 저작권 관리) 연동을 고려한다.
- 사용자의 편의성을 고려한다.
- 제품 소프트웨어 종류에 적합한 암호화 알고리즘을 적용한다.

#### (2) 패키징 작업 순서

- 패키징은 소프트웨어 개발 기법에 따라 각 주기가 끝날 때마다 패키징을 수행한다.
- 요즘은 IDE가 코딩부터 배포, 버전 관리 프로그램까지 전부 지원해서 별도의 패키징 도구를 사용하지 않아도 된다.

#### (3) 주요 배포용 파일 형식

msi : Window 용 패키지 형식
dmg : Mac Os용 패키지 형식
jar : java 응용 소프트웨어나 라이브러리를 배포하기 위한 패키지 형식
war : java Servlet, java Class, xml 및 웹 애플리케이션 서비스를 제공하기 위한 패키지 형식
ear : jar와 war 를 묶어 하나의 애플리케이션 서비스를 제공할 수 있는 패키지 형식
apk : 안드로이드용 앱 패키지 형식
ipa : iOS용 앱 패키지 형식

### 2) 릴리즈 노트

릴리즈 노트 : 사용자에게 제공하는 소프트웨어에 대한 정보.

릴리즈 노트를 통해 소프트웨어 버전관리나 릴리즈 정보를 관리 할 수 있다.

또한 출시 후 개선사항을 적용한 추가 배포시에 제공한다. 물론 철저한 테스트를 거친 것들이다.

#### (1) 릴리즈 노트 초기 버전 작성 시 고려사항

- 정확하고 완전한 정보 기반. 현재시제로 개발팀이 직접 작성한다.
- 신규 소스, 빌드 등의 이력이 정확히 관리되어 변경 개선된 항목의 이력 정보를 작성한다.
- 표준 형식은 없지만 일반적으로 머릿말(Header), 개요, 목적, 문제요약, 재현항목, 수정/개선내용, 사용자 영향도, SW 지원 영향도, 노트, 면책조항, 연락처 등을 포함해서 작성한다.

#### (2) 릴리즈 노트 추가 버전 작성 시 고려사항

- 긴급 버전 수정, 베타버전 출시, 업그레이드, 사용자 요청 등 특수 상황 발생 시 릴리즈 노트 추가 작성함.
- 이 때 추가 수정 후 릴리즈 노트를 내용을 담아 작성한다.

#### (3) 릴리즈 노트 작성 순서

모듈 식별 -> 릴리즈 정보 확인 -> 릴리즈 노트 개요 작성 -> 영향도 체크 -> 정식 릴리즈 노트 작성 -> 추가 개선 항목 식별


### 3) DRM(디지털 저작권 관리)

콘텐츠 보호 기술로, 클리어링 하우스에서 라이선스 정보를 소유하고 정책을 알려주면

패키저(maker)가 암호화해서 seller한테 주고 seller가 고객한테 팔면 고객은 클리어링 하우스에서 라이선스 받아서 쓴다.

DRM 컨트롤러는 권한을 통제하고 보안 컨테이너는 안전 유통을 할 수 있게 한다.

### 4) 버전등록(형상관리)

순서 ) import(첫 레퍼지토리에 파일 복사) -> check-out(저장소에서 파일 불러옴) -> check-in(수정한 뒤 저장소에 갱신) -> commit(저장)

방식 ) 공유폴더 방식, 클라/서버 방식(SVN), 분산저장소 방식(Git)



<hr>

## 4. 애플리케이션 테스트 관리

### 1) 애플리케이션 테스트 

잠재되어있는 결함을 찾아내는 일련의 행위

테스트 기본 원리 ) 완벽한 소프트웨어 테스팅은 불가능. 파레토 법칙 적용 가능(특정 모듈에 결함 집중), 살충제 패러독스(동일한 테스트케이스로 동일한 테스트 반복 시 결함이 반복하지 않는 현상), 오류-부재의 궤변(결함이 없지만 요구사항은 만족못함.)

테스트는 여러가지 기준으로 나눌 수 있다.

#### 프로그램 실행 여부)

1. 정적 테스트 : 프로그램 실행 안함. 워크스루(테스트 전문가들 초빙), 인스펙션(개발단계에서 미리 산출물을 평가. 테스트 단계를 미리 밟아서 오류를 줄임), 코드 검사 등

2. 동적 테스트 : 프로그램 실행함. 블랙박스 테스트, 화이트 박스 테스트

#### 테스트 기반 여부)

명세기반, 경험기반, 구조기반 테스트

구조 기반 테스트로는 화이트 박스 테스트. 명세, 경험 기반 테스트는 블랙박스 테스트.

- 화이트박스 테스트 : 내부가 다 보인다. 모듈의 코드를 다 까보고 논리적으로 잘 되는지 테스트한다. 뭐 하나 안빼먹고 테스트 해보는게 목표. 

ex) 기초경로검사(실행경로의 기초), 제어 구조 검사(조건검사, 루프 검사, 데이터 흐름 검사)

- 블랙박스 테스트 : 기능 테스트로 인터페이스에서 실시함. 

ex) 동치분할검사(테스트케이스를 안맞는거 맞는거 두개 가져와서 비교), 경계값분석(결과의 경계값을 테스트), 원인-효과 그래프 검사, 오류 예측검사, 비교 검사.


#### 누구를 기준으로 하냐)

개발자 시각에서 테스트하면 제대로 만들었는지를 보는 것이기 때문에 검증(Verification)테스트, 사용자 입장에서 요구사항대로 만들어졌는지 보는것이면 확인(Validation)테스트이다.


#### 목적에 따른 테스트)

 회복(복구력), 안전(불법침입 막는지), 강도(과부하테스트), 성능(효율성), 구조(논리), 회귀(결함 찾기 테스트), 병행(기존꺼 테스트) 테스트가 있다.


#### 계발 단계에 따라)

개발과 테스트를 엮으면 V-모델이 된다.

단위테스트(모듈) > 통합테스트(모듈끼리) > 시스템 테스트(컴퓨터 시스템) > 인수 테스트(요구사항)

##### 1. 인수 테스트)

알파테스트(개발자 앞에서 사용자가 테스트), 베타테스트(사용자 앞에서 개발자가 테스트)가 있다.

##### 2. 통합테스트)

단위로 되어있는 모듈들을 통합하는 과정에서 발생하는 오류를 테스트한다.

 이 때 하향식, 상향식으로 나뉘는데, 
 
 하향식은 상위 모듈에서부터 하위모듈 순으로 테스트하는 방법. 
 상향식은 하위 모듈 테스트들 마친 뒤 상위 모듈을 테스트 하는 방법이다.


모든 통합테스트는 일일히 할 수 없기 때문에 대충 뭉뚱그려서 테스트하는 것이 있는데, 하향은 그것들을 스텁(Stub)이라 말하고 종속모듈을 스텁으로 묶어서 한번에 테스트한다.

상향은 입출력 테스트를 위해 더미들을 묶어 드라이버(Driver)라고 말한다.

이 두개를 합쳐서 샌드위치식 통합테스트가 있는데 이는 섞어서 하는 것이다. 하위 수준에서는 상향, 상위 수준에서는 하향을 해서 둘이 만나는 것.


회귀 테스팅은 여러번 하는 것. 

#### 테스트 프로세스/순서 ) 

테스트 계획 -> 테스트 분석 및 디자인 -> 테스트 케이스 및 시나리오 작성 -> 테스트 수행 -> 테스트 결과 평가 및 리포팅 -> 결함 추적 및 관리 

#### 테스트 오라클 ) 

테스트케이스가 T/F인지 넣어주고 결과가 올바른지 확인한다.

#### 테스트 자동화 도구 ) 

휴먼에러 줄여주고 시간 줄여주지만 돈이 든다. 정적분석도구(프로그램실행x), 테스크 케이스 생성도구(자료흐름도, 기능테스트, 입력 도메인 분석, 랜덤테스트), 테스트 실행도구, 성능테스트 도구, 테스트 통제도구, 테스트 하네스 도구 등이 있다.



### 2) 결함 관리

Fault : 소프크웨어가 개발자가 설계한 것과 다르게 동작한다. 또는 다른 결과가 발생함.

순서 ) 결함관리계획 -> 결함 기록 -> 검토 -> 수정 -> 재확인 -> 상태추적(분포,추세,에이징) -> 결함 분석 및 보고서 작성

### 3) 애플리케이션 성능 분석

성능 : 사용자가 요구한 기능을 최소한의 자원을 사용해서 최대한 많은 기능을 신속하게 처리하는 정도.

측정 지표 : 처리량, 응답시간, 경과시간, 자원이용률

성능 저하 원인 : 애플리케이션을 DB에 연결할 때 Connection 객체를 생성하거나 쿼리를 실행하는 로직에서 많이 발생한다.

### 4) 복잡도 (중요)

https://y-oni.tistory.com/93

컴퓨터 과학에서 계산 이론의 분야로, 계산 문제를 푸는 알고리즘을 복잡도에 따라 문제의 모임을 구성하는 방법을 연구한다.

측정방법 ) LOC, 순한복잡도, 시간복잡도, 빅오표기법

순환복잡도 계산) V(G) = E(화살표수) - N(노드수) +2

<hr>

## 5. 데이터 인터페이스 확인(EAI)

