# 2과목 

## 3. 소프트웨어 개발
### 1) 소프트웨어 패키징

소프트웨어 패키징 : 기능별(=모듈별)로 생성한 실행파일들을 묶어 배포용 설치 파일을 만드는 것.

실행파일은 소스 코드 향후 관리를 고려해서 모듈화한다.

이 패키징은 개발자가 아니라 사용자가 사용할 것으로 생각하고 진행하며, 다양한 환경에서도 손쉽게 사용 가능하도록 일반적인 배포 형태로 패키징한다.

#### (1) 패키징 고려사항

- 사용자의 시스템 환경을 고려한다.
- UI는 사용자가 눈으로 직접 확인할 수 있도록 시각적인 자료와 메뉴얼을 함께 패키징한다.
- Managed Service 형태로 제공해서 문제발생 시 즉각 점검 수행이 가능하도록 한다.
- 내부 콘텐츠 암호화 및 보안을 고려한다.
- 여러 콘텐츠 간 DRM(디지털 저작권 관리) 연동을 고려한다.
- 사용자의 편의성을 고려한다.
- 제품 소프트웨어 종류에 적합한 암호화 알고리즘을 적용한다.

#### (2) 패키징 작업 순서

- 패키징은 소프트웨어 개발 기법에 따라 각 주기가 끝날 때마다 패키징을 수행한다.
- 요즘은 IDE가 코딩부터 배포, 버전 관리 프로그램까지 전부 지원해서 별도의 패키징 도구를 사용하지 않아도 된다.

#### (3) 주요 배포용 파일 형식

msi : Window 용 패키지 형식
dmg : Mac Os용 패키지 형식
jar : java 응용 소프트웨어나 라이브러리를 배포하기 위한 패키지 형식
war : java Servlet, java Class, xml 및 웹 애플리케이션 서비스를 제공하기 위한 패키지 형식
ear : jar와 war 를 묶어 하나의 애플리케이션 서비스를 제공할 수 있는 패키지 형식
apk : 안드로이드용 앱 패키지 형식
ipa : iOS용 앱 패키지 형식

### 2) 릴리즈 노트

릴리즈 노트 : 사용자에게 제공하는 소프트웨어에 대한 정보.

릴리즈 노트를 통해 소프트웨어 버전관리나 릴리즈 정보를 관리 할 수 있다.

또한 출시 후 개선사항을 적용한 추가 배포시에 제공한다. 물론 철저한 테스트를 거친 것들이다.

#### (1) 릴리즈 노트 초기 버전 작성 시 고려사항

- 정확하고 완전한 정보 기반. 현재시제로 개발팀이 직접 작성한다.
- 신규 소스, 빌드 등의 이력이 정확히 관리되어 변경 개선된 항목의 이력 정보를 작성한다.
- 표준 형식은 없지만 일반적으로 머릿말(Header), 개요, 목적, 문제요약, 재현항목, 수정/개선내용, 사용자 영향도, SW 지원 영향도, 노트, 면책조항, 연락처 등을 포함해서 작성한다.

#### (2) 릴리즈 노트 추가 버전 작성 시 고려사항

- 긴급 버전 수정, 베타버전 출시, 업그레이드, 사용자 요청 등 특수 상황 발생 시 릴리즈 노트 추가 작성함.
- 이 때 추가 수정 후 릴리즈 노트를 내용을 담아 작성한다.

#### (3) 릴리즈 노트 작성 순서

모듈 식별 -> 릴리즈 정보 확인 -> 릴리즈 노트 개요 작성 -> 영향도 체크 -> 정식 릴리즈 노트 작성 -> 추가 개선 항목 식별

...

<hr>

# 4. 애플리케이션 테스트 관리

## 1) 애플리케이션 테스트 

잠재되어있는 결함을 찾아내는 일련의 행위

테스트 기본 원리 ) 완벽한 소프트웨어 테스팅은 불가능. 파레토 법칙 적용 가능(특정 모듈에 결함 집중), 살충제 패러독스(동일한 테스트케이스로 동일한 테스트 반복 시 결함이 반복하지 않는 현상), 오류-부재의 궤변(결함이 없지만 요구사항은 만족못함.)

테스트는 두가지가 있다. 

1. 정적 테스트 : 프로그램 실행 안함. 워크스루(테스트 전문가들 초빙), 인스펙션(개발단계에서 미리 산출물을 평가. 테스트 단계를 미리 밟아서 오류를 줄임), 코드 검사 등
2. 동적 테스트 : 프로그램 실행함. 블랙박스 테스트, 화이트 박스 테스트

구조 기반 테스트로는 화이트 박스 테스트. 명세, 경험 기반 테스트는 블랙박스 테스트.

화이트박스 테스트 : 내부가 다 보인다. 모듈의 코드를 다 까보고 논리적으로 잘 되는지 테스트한다. 뭐 하나 안빼먹고 테스트 해보는게 목표. ex) 기초경로검사(실행경로의 기초), 제어 구조 검사(조건검사, 루프 검사, 데이터 흐름 검사)
블랙박스 테스트 : 기능 테스트로 인터페이스에서 실시함. ex) 동치분할검사(테스트케이스를 안맞는거 맞는거 두개 가져와서 비교), 경계값분석(결과의 경계값을 테스트), 원인-효과 그래프 검사, 오류 예측검사, 비교 검사.


누구를 기준으로 하냐고 봤을 때 개발자 시각에서 테스트하면 제대로 만들었는지를 보는 것이기 때문에 검증(Verification)테스트, 사용자 입장에서 요구사항대로 만들어졌는지 보는것이면 확인(Validation)테스트이다.

목적에 따른 테스트를 보았을 때, 회복(복구력), 안전(불법침입 막는지), 강도(과부하테스트), 성능(효율성), 구조(논리), 회귀(결함 찾기 테스트), 병행(기존꺼 테스트) 테스트가 있다.

개발과 테스트를 엮으면 V-모델이 된다.

단위테스트(모듈) > 통합테스트(모듈끼리) > 시스템 테스트(컴퓨터 시스템) > 인수 테스트(요구사항)

인수 테스트에는 알파테스트(개발자 앞에서 사용자가 테스트), 베타테스트(사용자 앞에서 개발자가 테스트)

통합테스트는 단위로 되어있는 모듈들을 통합하는 과정에서 발생하는 오류를 테스트한다. 이 떄 하향식, 상향식으로 나뉘는데, 하향식은 상위 모듈에서부터 하위모듈 순으로 테스트하는 방법. 상향식은 하위 모듈 테스트들 마친 뒤 상위 모듈을 테스트 하는 방법이다.

모든 통합테스트는 일일히 할 수 없기 때문에 대충 뭉뚱그려서 테스트하는 것이 있는데, 하향은 그것들을 스텁(Stub)이라 말하고 종속모듈을 스텁으로 묶어서 한번에 테스트한다.

상향은 입출력 테스트를 위해 더미들을 묶어 드라이버(Driver)라고 말한다.

이 두개를 합쳐서 샌드위치식 통합테스트가 있는데 이는 섞어서 하는 것이다. 하위 수준에서는 상향, 상위 수준에서는 하향을 해서 둘이 만나는 것.

회귀 테스팅은 여러번 하는 것. 

