/* 

문제 설명

주어진 숫자 중 3개의 수를 더했을 때 소수가 되는 경우의 개수를 구하려고 합니다. 숫자들이 들어있는 배열 nums가 매개변수로 주어질 때, 
nums에 있는 숫자들 중 서로 다른 3개를 골라 더했을 때 소수가 되는 경우의 개수를 return 하도록 solution 함수를 완성해주세요.

제한사항
nums에 들어있는 숫자의 개수는 3개 이상 50개 이하입니다.
nums의 각 원소는 1 이상 1,000 이하의 자연수이며, 중복된 숫자가 들어있지 않습니다.

입출력 예
nums	result
[1,2,3,4]	1
[1,2,7,6,4]	4

입출력 예 #1
[1,2,4]를 이용해서 7을 만들 수 있습니다.
입출력 예 #2
[1,2,4]를 이용해서 7을 만들 수 있습니다.
[1,4,6]을 이용해서 11을 만들 수 있습니다.
[2,4,7]을 이용해서 13을 만들 수 있습니다.
[4,6,7]을 이용해서 17을 만들 수 있습니다.

*/

// 소수 찾기가 어려웠다. 베스트 답안 공부함.

function solution(nums) {
    let answer = 0;
    //3개를 뽑는다고 하면 각각 다른 인덱스의 숫자를 한개씩 뽑는 것이다.
    for(let i = 0; i < nums.length; i++) { //맨 앞에꺼부터 뽑고
        
        for(let j = i+1; j < nums.length; j++) { //앞에꺼 다음꺼 뽑고
            
            for(let k = j+1; k < nums.length; k++) { //그 앞에꺼 다음꺼 뽑고
            
                // 0+1+2, 0+1+3, 0+2+3, 1+2+3              
                const sum = nums[i] + nums[j] + nums[k];
                
                if(isPrime(sum)) //소수면
                    answer++; //answer값을 하나 추가해라.
            }
        }
    }
    return answer;
}

function isPrime(sum) { //소수 판별
    for(let i = 2; i < sum; i++){ //합계가 갯수만큼 하는데
        if(sum % i === 0) //합계를 2,3,4,5를 나눴을 때 나머지가 0과 같다면
            return false; //안된다.
    } //자기 자신을 나눴는데 나머지가 0이다 => 자기 앞에 숫자들 나누면 나머지가 생기고 자기 자신을 나눴을때 나머지가 없으면 소수이다.
    //return sum > 1; //sum은 1보다 크다?
    return true;
}



/*
문제풀이
소수는 자기 앞에 숫자들을 다 나눠서 나머지가 남는데, 자기 자신을 나눴을 때 처음으로 나머지가 0인 숫자이다.
이 개념을 잘 알아야할 것.

또한 겹치지 않게 3개를 숫자를 뽑는다고 하면 for문을 3중으로 해서 각각의 인덱스가 겹치지 않게 해서 그 값들을 뽑는 것임을 기억하자.
좋은 문제였다.
*/


/* 2022-02-16 */